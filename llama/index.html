<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Purple Earth Hypothesis">
    <meta property="og:type" content="website">
    <meta name="color-scheme" content="dark">

    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
      <meta property="og:type" content="article">
      <meta property="og:title" content="
Llama - A Programmable Modular Synth in OCaml
">
      <link rel="canonical" href="https://gridbugs.github.io/purpleearthhypothesis.com/llama/">
      <meta property="og:url" content="https://gridbugs.github.io/purpleearthhypothesis.com/llama/">

      
        <meta name="description" content="DIY Synthesizer Blog">
        <meta property="og:description" content="DIY Synthesizer Blog">
      

      
        <meta property="article:published_time" content="2026-01-02T00:00:00+00:00">
      
      
        <meta property="og:image" content="https://gridbugs.github.io/purpleearthhypothesis.com/llama/live.png">
      
    

    <meta property="og:image" content="https://gridbugs.github.io/purpleearthhypothesis.com/ibis.png">


    <link rel="icon" type="image/x-icon" href="https://gridbugs.github.io/purpleearthhypothesis.com/favicon.png">
    <link rel="alternate" type="application/rss+xml" title="Purple Earth Hypothesis" href="https://gridbugs.github.io/purpleearthhypothesis.com/rss.xml">
    <link rel="alternate" type="application/atom+xml" title="Purple Earth Hypothesis" href="https://gridbugs.github.io/purpleearthhypothesis.com/atom.xml">

    <link rel="stylesheet" href="https://gridbugs.github.io/purpleearthhypothesis.com/style.css">
    <title>
Llama - A Programmable Modular Synth in OCaml
</title>
  </head>
  <body>
    <div id="page">
      <!-- Empty tag so that the normal scroll target has something apply to,
        even though it has no visible effect. Without this the "ibis" scroll target
        would always be active. -->
        <a href="#normal-scroll-target"></a>

        <div id="columns">

          <div id="left"></div>

          <div id="right">
            <div id="keyboard" class="margin-decoration">
              <div id="key-24"></div>
              <div id="key-23-b"></div>
              <div id="key-22"></div>
              <div id="key-23-f"></div>
              <div id="key-21-b"></div>
              <div id="key-20"></div>
              <div id="key-21-f"></div>
              <div id="key-19-b"></div>
              <div id="key-18"></div>
              <div id="key-19-f"></div>
              <div id="key-17"></div>
              <div id="key-16-b"></div>
              <div id="key-15"></div>
              <div id="key-16-f"></div>
              <div id="key-14-b"></div>
              <div id="key-13"></div>
              <div id="key-14-f"></div>
              <div id="key-12"></div>
              <div id="key-11-b"></div>
              <div id="key-10"></div>
              <div id="key-11-f"></div>
              <div id="key-9-b"></div>
              <div id="key-8"></div>
              <div id="key-9-f"></div>
              <div id="key-7-b"></div>
              <div id="key-6"></div>
              <div id="key-7-f"></div>
              <div id="key-5"></div>
              <div id="key-4-b"></div>
              <div id="key-3"></div>
              <div id="key-4-f"></div>
              <div id="key-2-b"></div>
              <div id="key-1"></div>
              <div id="key-2-f"></div>
              <div id="key-0"></div>
            </div>
          </div>

          <div id="mid">
            <div id="content">
                <header>
  <div id="header-nav-container">
    <nav>
      <ul>
        <li><a href="https://gridbugs.github.io/purpleearthhypothesis.com">Purple Earth Hypothesis</a></li>
        <li class="first-rhs"><a href="https://gridbugs.github.io/purpleearthhypothesis.com/about">About</a></li>
        <li><a href="https://gridbugs.github.io/purpleearthhypothesis.com/blog">Blog</a></li>
      </ul>
    </nav>
  </div>
</header>

                




<article>
<h1 class="title">Llama - A Programmable Modular Synth in OCaml</h1>

  
<p class="post-meta">
  <time datetime="2026-01-02T00:00:00+00:00">
    January 02, 2026
  </time>
  
  in
  
  <a href="https://gridbugs.github.io/purpleearthhypothesis.com/tags/project" aria-label="tag">project</a>
  <a href="https://gridbugs.github.io/purpleearthhypothesis.com/tags/software" aria-label="tag">software</a>
  
</p>


  

<p>Building analog synthesizers was slow going at the start.
I had lots of questions, and when I found answers they often led to more questions.
What type of cables should I use, what voltage should the power supply be,
what’s the diameter of the holes I need to drill to attach knobs, buttons, jack sockets, etc?
What material should the front panel be made of and how do I cut it to size? What size should it even be?
Most synth circuits require a negative voltage but how do I produce one?</p>
<p>In the midst of this I was traveling to France for work (I’m a programmer) and on the flight
I had the idea that a synthesizer module like an oscillator or filter with input jacks and output jacks
can be thought of as a function. It takes some inputs (signals from other module, knob positions, etc)
and produces some outputs which can then be passed to other functions, and so on.
Just like the mess of cables patching together the modules of a modular synhesizer.</p>
<p>Eventually I’d end up with a library for building highly customizable MIDI-controlled programmable synthesizers
like the one used in the workflow pictured below (a screenshot from <a href="https://www.youtube.com/watch?v=bkKAFVH8G8g">this video</a>).
<img src="https://gridbugs.github.io/purpleearthhypothesis.com/llama/live.png" alt="3 windows. A terminal with a command to start the synth, a visualization of the synth’s output, and a webcam shot of me playing a midi keyboard." /></p>
<p>I started hacking on a <a href="https://github.com/gridbugs/synth-experiment-rust">prototype</a> in Rust because
the Rust library <a href="https://github.com/RustAudio/cpal">cpal</a> makes it very easy to play sound programatically.
Then I caught covid and spent the next few weeks isolating and recovering.
Lots of time lying in bed in a hotel room in a very inconvenient timezone for talking to people back home.
I spent most of that time developing my prototype.</p>
<p>The core idea is <em>signals of values</em>, which are streams of values produced at
the sample rate of the computer’s sound card (probably about 44kHz).
A signal of <code>float</code>s would be suitable for representing an audio signal, but
you can also have signals of <code>bool</code>s to represent the state of a button or key.
Synth modules are functions that take signals and produce new signals in return.
This way modules can be composed to produce arbitrarily complex “patches”, just
like in an analog modular synth. I refer to this approach as a <em>software-defined modular synthesizer</em>.</p>
<p>For example here’s the signature of the envelope generator. <code>Sf64</code> is a signal of <code>float</code>s and <code>Sbool</code> is a
signal of <code>bool</code>s.</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">fn </span><span>adsr_envelope_lin_01</span><span style="color:#cccccc;">(
</span><span style="color:#cccccc;">    </span><span style="font-style:italic;color:#8aa6c1;">gate</span><span style="color:#cccccc;">: Sbool,
</span><span style="color:#cccccc;">    </span><span style="font-style:italic;color:#8aa6c1;">attack_seconds</span><span style="color:#cccccc;">: Sf64,
</span><span style="color:#cccccc;">    </span><span style="font-style:italic;color:#8aa6c1;">decay_seconds</span><span style="color:#cccccc;">: Sf64,
</span><span style="color:#cccccc;">    </span><span style="font-style:italic;color:#8aa6c1;">sustain_01</span><span style="color:#cccccc;">: Sf64,
</span><span style="color:#cccccc;">    </span><span style="font-style:italic;color:#8aa6c1;">release_seconds</span><span style="color:#cccccc;">: Sf64,
</span><span style="color:#cccccc;">) -&gt; Sf64
</span></code></pre>
<p>All the arguments to this function are signals which allows the properties of
the envelope to be changed in real-time. If you want a fixed value, there’s a function
that takes a single value and makes a signal that always has that value:</p>
<pre data-lang="rust" style="background-color:#191919;color:#ffffff;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#80d500;">fn </span><span>const_</span><span style="color:#cccccc;">&lt;T: </span><span style="color:#8aa6c1;">Clone</span><span style="color:#cccccc;">&gt;(</span><span style="font-style:italic;color:#8aa6c1;">value</span><span style="color:#cccccc;">: T) -&gt; BufferedSignal&lt;T&gt;
</span></code></pre>
<p>The hardest part was figuring out how to implement digital filters.
The most obvious implementation of a low-pass filter to me (take the average of the previous K samples)
doesn’t sound very good, so I went looking for alternatives.
What I found was a lot of maths that I barely understood, and not really geared towards
a real-world implementation. I didn’t want to get sidetracked by a DSP rabbit hole just yet.
Fortunately I came across <a href="https://exstrom.com/journal/sigproc/dsigproc.html">this</a> reference implementation
of a couple of well-known filters, which I re-implemented in Rust.</p>
<p>The prototype still works on macOS, but due to some SDL-related bitrotting it doesn’t work
on Linux anymore. Use the computer keyboard to play
notes and use the mouse to control the filter. The code is <a href="https://github.com/gridbugs/synth-experiment-rust">here</a>.</p>
<p>Here’s a screenshot.
It’s pixelated because it renders with my <a href="https://github.com/gridbugs/chargrid">roguelike ascii graphics
library</a> because that was the easiest way
I knew how to render to the screen in Rust (ie. the “pixels” are actually spaces).</p>
<p><img src="https://gridbugs.github.io/purpleearthhypothesis.com/llama/prototype.png" alt="An oscilloscope visualization of a sound wave in a window" /></p>
<p>My company has a policy where we can use the last two days of each month to work on personal projects
<em>as long as they are written in OCaml</em> (we make OCaml development tools).
I used two of these days to port my prototype to OCaml, and then took it further adding MIDI (devices and files).
This was the beginning of <a href="https://github.com/gridbugs/llama">Llama</a> - a
software-defined modular synthesizer in OCaml.</p>
<p>For comparison with the Rust envelope generator above, here’s how it looks in Llama. The <code>'a t</code> type
represents a signals whose values are of type <code>'a</code>, and the <code>Gate.t</code> type is an  for <code>bool t</code>.</p>
<pre data-lang="ocaml" style="background-color:#191919;color:#ffffff;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span>val </span><span style="color:#cccccc;">adsr_linear :
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">gate</span><span style="font-style:italic;color:#8aa6c1;">:</span><span style="color:#80d500;">Gate</span><span style="font-style:italic;color:#8aa6c1;">.</span><span style="color:#80d500;">t </span><span style="color:#cccccc;">-&gt;
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">attack_s</span><span style="font-style:italic;color:#8aa6c1;">:</span><span style="color:#80d500;">float t </span><span style="color:#cccccc;">-&gt;
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">decay_s</span><span style="font-style:italic;color:#8aa6c1;">:</span><span style="color:#80d500;">float t </span><span style="color:#cccccc;">-&gt;
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">sustain_01</span><span style="font-style:italic;color:#8aa6c1;">:</span><span style="color:#80d500;">float t </span><span style="color:#cccccc;">-&gt;
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">release_s</span><span style="font-style:italic;color:#8aa6c1;">:</span><span style="color:#80d500;">float t </span><span style="color:#cccccc;">-&gt;
</span><span style="color:#cccccc;">  </span><span style="color:#80d500;">float t
</span></code></pre>
<p>This uses one of my favourite features of OCaml: named function arguments. When calling <code>adsr_linear</code>,
each argument must be passed by name, as in the following example. Variables named the same as arguments
can be <em>punned</em> (e.g. <code>~gate:gate</code> can be written as simply <code>~gate</code>):</p>
<pre data-lang="ocaml" style="background-color:#191919;color:#ffffff;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#cccccc;">adsr_linear </span><span style="color:#80d500;">~gate ~attack_s:</span><span style="color:#cccccc;">(const </span><span style="color:#eddd5a;">0.01</span><span style="color:#cccccc;">) </span><span style="color:#80d500;">~decay_s:</span><span style="color:#cccccc;">(const </span><span style="color:#eddd5a;">0.4</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">    </span><span style="color:#80d500;">~sustain_01:</span><span style="color:#cccccc;">(const </span><span style="color:#eddd5a;">1.0</span><span style="color:#cccccc;">) </span><span style="color:#80d500;">~release_s
</span></code></pre>
<p>It’s typical for modules to have many input signals, and if they’re just passed as regular arguments then it
can be hard to quickly tell the meaning of each input. Most languages lack a mechanism for named arguments,
so this is a situation where OCaml really shines.</p>
<p>Another OCaml feature that’s a good fit for this style of programming is the pipeline operator <code>|&gt;</code>, which is
an infix operator that passes the value on its left to the function on its right. This allows a sequence of
transformations to be written from left to right, like:</p>
<pre data-lang="ocaml" style="background-color:#191919;color:#ffffff;" class="language-ocaml "><code class="language-ocaml" data-lang="ocaml"><span style="color:#cccccc;">mk_voices input.keyboard
</span><span>|&gt;</span><span style="color:#cccccc;"> chebyshev_low_pass_filter
</span><span style="color:#cccccc;">     </span><span style="color:#80d500;">~cutoff_hz:</span><span style="color:#cccccc;">(mouse_x </span><span>|&gt;</span><span style="color:#cccccc;"> exp_01 </span><span style="color:#eddd5a;">4.0 </span><span>|&gt;</span><span style="color:#cccccc;"> scale </span><span style="color:#eddd5a;">8000.0 </span><span>|&gt;</span><span style="color:#cccccc;"> offset </span><span style="color:#eddd5a;">100.0</span><span style="color:#cccccc;">)
</span><span style="color:#cccccc;">     </span><span style="color:#80d500;">~resonance:</span><span style="color:#cccccc;">(mouse_y </span><span>|&gt;</span><span style="color:#cccccc;"> exp_01 </span><span style="color:#eddd5a;">1.0 </span><span>|&gt;</span><span style="color:#cccccc;"> scale </span><span style="color:#eddd5a;">10.0</span><span style="color:#cccccc;">)
</span><span>|&gt;</span><span style="color:#cccccc;"> echo </span><span style="color:#80d500;">~f:</span><span style="color:#cccccc;">(signal </span><span>|&gt;</span><span style="color:#cccccc;"> scale </span><span style="color:#eddd5a;">0.6</span><span style="color:#cccccc;">) </span><span style="color:#80d500;">~delay_s:</span><span style="color:#cccccc;">(const </span><span style="color:#eddd5a;">0.3</span><span style="color:#cccccc;">)
</span><span>|&gt;</span><span style="color:#cccccc;"> echo </span><span style="color:#80d500;">~f:</span><span style="color:#cccccc;">(signal </span><span>|&gt;</span><span style="color:#cccccc;"> scale </span><span style="color:#eddd5a;">0.6</span><span style="color:#cccccc;">) </span><span style="color:#80d500;">~delay_s:</span><span style="color:#cccccc;">(const </span><span style="color:#eddd5a;">0.5</span><span style="color:#cccccc;">)
</span></code></pre>
<p>The <code>mk_voices</code> function takes a handle to the (computer) keyboard and returns an audio
signal from a keyboard-controlled synth voice. The code above applies several
effects: a low-pass filter with the cutoff and resonance controlled by the
mouse position, and then a pair of echo effects that add a time-delayed copy of
the signal to itself. It’s very natural to write synth code like this when you have
a chain of modules with one interesting input and output. You can think of
plugging the output of one module into the input of the next one in the chain.</p>
<p>I added a graphical window for visualization, and to allow keyboard and mouse input to control the synth.
Here’s an early screenshot. This time it’s pixelated because the number of audio samples per frame is less than
the width of the window, and I was too lazy to maintain a buffer of old samples for the purpose of visualization.</p>
<p><img src="https://gridbugs.github.io/purpleearthhypothesis.com/llama/screenshot.png" alt="A purple oscilloscope visualization of a sound wave in a window" /></p>
<p>To play generated audio samples in real time, Llama originally used the Rust library <a href="https://github.com/RustAudio/cpal">cpal</a>
by way of <a href="https://github.com/zshipko/ocaml-rs">ocaml-rs</a> which allows for OCaml interoperability with Rust.
I’ve since switch to <a href="https://github.com/xiph/libao">libao</a> to simplify the build process to not involve Rust.</p>
<p>As I developed Llama further I started to get frustrated with OCaml’s tooling ecosystem.
It seemed like nothing worked the way I’d expect it to, and I was always getting nasty surprises.
I’ve written about all the problems I ran into <a href="https://www.gridbugs.org/frustrating-interactions-with-the-ocaml-ecosystem-while-developing-a-synthesizer-library/">over on my other blog</a>.
I stopped working on Llama and migrated the ideas to a new project in Rust that would eventually become <a href="https://github.com/gridbugs/caw">CAW</a>,
but more on that in a later post.</p>
<p>Llama still works, and it is lots of fun to play around with.
<a href="https://www.gridbugs.org/sound-on-ocaml-on-windows/">It even sort of works on Windows</a> which is no easy feat for an OCaml program.
There are a bunch of example programs in the <code>examples</code> folder.
Some of the examples are <a href="https://github.com/gridbugs/llama?tab=readme-ov-file#llama-in-action">recorded</a>.
My favourites are probably <a href="https://youtu.be/1ndhPlvDBH8">this</a> and <a href="https://youtu.be/o-XPH1j0NqE">this</a>.</p>
<p>I also did a couple of live jams using Llama’s support for live MIDI input which I’ve put on youtube <a href="https://www.youtube.com/watch?v=bkKAFVH8G8g">here</a> and <a href="https://www.youtube.com/watch?v=vvgth-ZZq_8">here</a>.</p>

</article>


<div class="next-prev-nav-container">
  <nav>
    <ul>
      
      
      
      
      <li class="nav-prev">
	
	<a href="https:&#x2F;&#x2F;gridbugs.github.io&#x2F;purpleearthhypothesis.com&#x2F;nes-audio-playground&#x2F;" aria-label="Previous">
	  Previous: NES Audio Playground
	</a>
	
      </li>
      <li class="nav-next">
	
	<a href="https:&#x2F;&#x2F;gridbugs.github.io&#x2F;purpleearthhypothesis.com&#x2F;breadboard-synth&#x2F;" aria-label="Next">
	  Next: Breadboard Synth
	</a>
	
      </li>
    </ul>
  </nav>
</div>



                <!-- end of "content" -->
            </div>

            <footer>
  <div class="copyright">
      © 2025-2026 <a href="https://www.purpleearthhypothesis.com">purpleearthhypothesis.com</a>
  </div>
</footer>


            <!-- end of "mid" -->
          </div>

          <!-- end of "columns" -->
        </div>

        <a id="spin" class="ibis-size margin-decoration" href="#ibis-scroll-target">
          <div id="glasses-left" class="glasses ibis-size"></div>
          <div id="glasses-right" class="glasses ibis-size"></div>
          <div id="ibis" class="ibis-size"></div>
        </a>

        <div id="normal-scroll-target"></div>
        <div id="ibis-scroll-target"></div>

        <div id="lowsky"></div>
        <div id="horizon"></div>
        <div id="mountains"></div>
        <div id="mountains-base"></div>
        <div id="mountains-base-brighter"></div>
        <div id="ground">
          <div id="grid-overlay1"></div>
          <div id="grid-overlay2"></div>
          <div id="grid"></div>
        </div>

        <div id="palm1" class="palm"></div>
        <div id="palm2" class="palm"></div>

        <div id="star-container"></div>

        <!-- end of "page" -->
    </div>
    <script>
      const NUM_STARS = 500;
      const MAX_STAR_TOP_PX = 8000;
      function make_star() {
        const star = document.createElement("div");
        star.style.left = `${parseInt(Math.random() * 94 + 2)}%`;
        star.style.top = `${parseInt(Math.random() * MAX_STAR_TOP_PX)}px`;
        star.style.fontSize = `${parseInt(Math.random() * 20 + 8)}px`;
        return star;
      }
      const star_container = document.getElementById("star-container");
      for (let i = 0; i < NUM_STARS; i++) {
        star_container.appendChild(make_star());
      }
    </script>
    <script type="text/javascript" src="https://gridbugs.github.io/purpleearthhypothesis.com/keyboard.js"></script>
    <script>
      run_keyboard("https://gridbugs.github.io/purpleearthhypothesis.com/assets/keyboard-color-map.png");
    </script>
  </body>
</html>
